package bean17.cha;


import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

/**
 * Cyclical figurate numbers
 * Problem 61
 * Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are generated by the following formulae:
 * <p/>
 * Triangle	 	P3,n=n(n+1)/2	 	1, 3, 6, 10, 15, ...
 * Square	 	P4,n=n2	 	1, 4, 9, 16, 25, ...
 * Pentagonal	 	P5,n=n(3n−1)/2	 	1, 5, 12, 22, 35, ...
 * Hexagonal	 	P6,n=n(2n−1)	 	1, 6, 15, 28, 45, ...
 * Heptagonal	 	P7,n=n(5n−3)/2	 	1, 7, 18, 34, 55, ...
 * Octagonal	 	P8,n=n(3n−2)	 	1, 8, 21, 40, 65, ...
 * The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.
 * <p/>
 * The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number with the first).
 * Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882), is represented by a different number in the set.
 * This is the only set of 4-digit numbers with this property.
 * Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.
 */
public class Problem61 {
    final int N = 6;

    final int MIN = 1000;
    final int MAX = 10000;

    final int[][] datas = new int[N][];

    /**
     * @param args arguments
     */
    public static void main(String[] args) {
        new Problem61().testCyclicalFigurateNumbers();
    }

    @SuppressWarnings({"unchecked"})
    private void testCyclicalFigurateNumbers() {
        long start = System.currentTimeMillis();

        for (int i = 0; i < N; i++) {
            List<Integer> list = new ArrayList<Integer>();
            int n2 = compute(i, 0);
            for (int j = 0; n2 < MAX; j++, n2 = compute(i, j)) {
                if (n2 >= MIN) {
                    list.add(n2);
                }
            }
            datas[i] = new int[list.size()];
            for (int j = 0; j < list.size(); j++) {
                datas[i][j] = list.get(j);
            }
        }

        Stack<ArrayList<Node>> stack = new Stack<ArrayList<Node>>();
        ArrayList<Node> result = null;

        for (int i = 0; i < datas[N - 1].length; i++) {
            ArrayList<Node> list = new ArrayList<Node>();
            list.add(new Node(N - 1, i));
            stack.push(list);
        }

        boolean find = false;
        int resultValue = 0;

        while (!find) {
            ArrayList<Node> list = stack.pop();
            if (N == list.size()) {
                Node last = list.get(list.size() - 1);
                int lastValue = datas[last.i][last.j];

                Node first = list.get(0);
                int firstValue = datas[first.i][first.j];

                if ((lastValue % 100) == (firstValue / 100)) {
                    find = true;
                    result = list;
//                    break;
                } else {
                    if (stack.isEmpty()) {
                        break;
                    }
                }
            } else {
                Node last = list.get(list.size() - 1);
                int lastValue = datas[last.i][last.j];

                for (int i = 0; i < N; i++) {
                    if (!contain(list, i)) {
                        int low = lastValue % 100;
                        if (low >= 10) {
                            SearchResult searchResult = search(low, i);
                            if (null != searchResult) {
                                for (int j = searchResult.start; j <= searchResult.end; j++) {
                                    ArrayList<Node> copyed;
                                    copyed = (ArrayList<Node>) list.clone();
                                    copyed.add(new Node(i, j));
                                    stack.push(copyed);
                                }
                            }
                        }
                    }
                }
            }
        }

        if (find) {
            for (int i = 0; i < result.size(); i++) {
                Node node = result.get(i);
                int value = datas[node.i][node.j];
                resultValue += value;
                System.out.println(node + " " + value);
            }
        }

        System.out.println("c = " + resultValue);

        System.out.println("cost time : "
                + (System.currentTimeMillis() - start) + "ms.");
    }

    boolean contain(List<Node> list, int offset) {
        boolean contain = false;
        for (Node node : list) {
            if (node.i == offset) {
                contain = true;
                break;
            }
        }
        return contain;
    }

    class Node {
        int i;
        int j;

        public Node(int i, int j) {
            this.i = i;
            this.j = j;
        }

        @Override
        public String toString() {
            return "Node{" +
                    "i=" + i +
                    ", j=" + j +
                    '}';
        }
    }

    SearchResult search(int high, int index) {
        int start = 0;
        int end = datas[index].length - 1;

        int middile;

        while (start <= end) {
            middile = (start + end) / 2;
            int high2 = datas[index][middile] / 100;
            if (high2 == high) {
                int start2 = middile;
                int end2 = middile;

                for (int i = middile - 1; i >= start; i--) {
                    high2 = datas[index][i] / 100;
                    if (high2 == high) {
                        start2 = i;
                    } else {
                        break;
                    }
                }

                for (int i = middile + 1; i <= end; i++) {
                    high2 = datas[index][i] / 100;
                    if (high2 == high) {
                        end2 = i;
                    } else {
                        break;
                    }
                }

                return new SearchResult(end2, start2);
            }
            if (high2 > high) {
                end = middile - 1;
            } else {
                start = middile + 1;
            }
        }

        return null;
    }

    class SearchResult {
        int start;
        int end;


        @Override
        public String toString() {
            return "SearchResult{" +
                    "start=" + start +
                    ", end=" + end +
                    '}';
        }

        public SearchResult(int end, int start) {
            this.end = end;
            this.start = start;
        }


    }

    int compute(int index, int n) {
        if (0 == index) {
            return triangle(n);
        } else if (1 == index) {
            return square(n);
        } else if (2 == index) {
            return pentagonal(n);
        } else if (3 == index) {
            return hexagonal(n);
        } else if (4 == index) {
            return heptagonal(n);
        } else if (5 == index) {
            return octagonal(n);
        }

        return 0;
    }

    /**
     * Triangle	 	P3,n=n(n+1)/2
     *
     * @return value
     */
    int triangle(int n) {
        return n * (n + 1) / 2;
    }

    /**
     * Square	 	P4,n=n2
     *
     * @param n value
     * @return value
     */

    int square(int n) {
        return n * n;
    }

    /**
     * Pentagonal	 	P5,n=n(3n−1)/2
     *
     * @param n value
     * @return value
     */

    int pentagonal(int n) {
        return n * (3 * n - 1) / 2;
    }

    /**
     * Hexagonal	P6,n=n(2n−1)
     *
     * @param n value
     * @return value
     */

    int hexagonal(int n) {
        return n * (2 * n - 1);
    }

    /**
     * Heptagonal	 	P7,n=n(5n−3)/2
     *
     * @param n value
     * @return value
     */

    int heptagonal(int n) {
        return n * (5 * n - 3) / 2;
    }

    /**
     * Octagonal	 	P8,n=n(3n−2)
     *
     * @param n value
     * @return value
     */
    int octagonal(int n) {
        return n * (3 * n - 2);
    }
}
